// Code generated by proto-gen-gogo. DO NOT EDIT.
// source: github.com/gpm2/gpm/proto/apis/gpm/v1/gpm.proto

package gpmv1

import (
	ebinary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = ebinary.BigEndian

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

type Service struct {
	// 服务名称
	// +gen:required
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 执行器路径
	// +gen:required
	Bin string `protobuf:"bytes,2,opt,name=bin,proto3" json:"bin,omitempty"`
	// 服务启动参数
	Args []string `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	// 服务进程 id
	Pid int64 `protobuf:"varint,4,opt,name=pid,proto3" json:"pid,omitempty"`
	// 服务目录
	Dir string `protobuf:"bytes,5,opt,name=dir,proto3" json:"dir,omitempty"`
	// 服务环境变量
	Env map[string]string `protobuf:"bytes,6,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// 服务系统参数
	SysProcAttr *SysProcAttr `protobuf:"bytes,7,opt,name=sysProcAttr,proto3" json:"sysProcAttr,omitempty"`
	// 服务进程日志配置
	Log *ProcLog `protobuf:"bytes,8,opt,name=log,proto3" json:"log,omitempty"`
	// 服务版本
	Version string `protobuf:"bytes,9,opt,name=version,proto3" json:"version,omitempty"`
	// 是否自启动, 默认为 false
	AutoRestart int32 `protobuf:"varint,10,opt,name=autoRestart,proto3" json:"autoRestart,omitempty"`
	// 创建时间
	CreationTimestamp int64 `protobuf:"varint,21,opt,name=creationTimestamp,proto3" json:"creationTimestamp,omitempty"`
	// 修改时间
	UpdateTimestamp int64 `protobuf:"varint,22,opt,name=updateTimestamp,proto3" json:"updateTimestamp,omitempty"`
	// 启动时间
	StartTimestamp int64 `protobuf:"varint,23,opt,name=startTimestamp,proto3" json:"startTimestamp,omitempty"`
	// 服务状态
	// +gen:enum=[init,running,stopped,failed,upgrading]
	Status string `protobuf:"bytes,24,opt,name=status,proto3" json:"status,omitempty"`
	// 服务状态为 failed 的错误信息
	Msg string `protobuf:"bytes,25,opt,name=msg,proto3" json:"msg,omitempty"`
	// 服务资源占用情况
	Stat *Stat `protobuf:"bytes,26,opt,name=stat,proto3" json:"stat,omitempty"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{0}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.XSize()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

type SysProcAttr struct {
	// 执行命令时所在的根目录
	Chroot string `protobuf:"bytes,1,opt,name=chroot,proto3" json:"chroot,omitempty"`
	// 执行服务时所用的 uid (windows 无效)
	Uid int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// uid 对应的用户名称
	User string `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// 执行服务时所有的 gid (windows 无效)
	Gid int32 `protobuf:"varint,4,opt,name=gid,proto3" json:"gid,omitempty"`
	// gid 对应的用户组
	Group string `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty"`
}

func (m *SysProcAttr) Reset()         { *m = SysProcAttr{} }
func (m *SysProcAttr) String() string { return proto.CompactTextString(m) }
func (*SysProcAttr) ProtoMessage()    {}
func (*SysProcAttr) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{1}
}
func (m *SysProcAttr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysProcAttr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysProcAttr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysProcAttr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysProcAttr.Merge(m, src)
}
func (m *SysProcAttr) XXX_Size() int {
	return m.XSize()
}
func (m *SysProcAttr) XXX_DiscardUnknown() {
	xxx_messageInfo_SysProcAttr.DiscardUnknown(m)
}

var xxx_messageInfo_SysProcAttr proto.InternalMessageInfo

type ProcLog struct {
}

func (m *ProcLog) Reset()         { *m = ProcLog{} }
func (m *ProcLog) String() string { return proto.CompactTextString(m) }
func (*ProcLog) ProtoMessage()    {}
func (*ProcLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{2}
}
func (m *ProcLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcLog.Merge(m, src)
}
func (m *ProcLog) XXX_Size() int {
	return m.XSize()
}
func (m *ProcLog) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcLog.DiscardUnknown(m)
}

var xxx_messageInfo_ProcLog proto.InternalMessageInfo

type Stat struct {
	// cpu 占用百分比
	CpuPercent float64 `protobuf:"fixed64,1,opt,name=cpuPercent,proto3" json:"cpuPercent,omitempty"`
	// 内存占用, rss
	Memory uint64 `protobuf:"varint,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// 内存占用百分比
	MemPercent float32 `protobuf:"fixed32,3,opt,name=memPercent,proto3" json:"memPercent,omitempty"`
}

func (m *Stat) Reset()         { *m = Stat{} }
func (m *Stat) String() string { return proto.CompactTextString(m) }
func (*Stat) ProtoMessage()    {}
func (*Stat) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{3}
}
func (m *Stat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Stat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Stat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Stat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Stat.Merge(m, src)
}
func (m *Stat) XXX_Size() int {
	return m.XSize()
}
func (m *Stat) XXX_DiscardUnknown() {
	xxx_messageInfo_Stat.DiscardUnknown(m)
}

var xxx_messageInfo_Stat proto.InternalMessageInfo

type GpmInfo struct {
	Version   string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	GitCommit string `protobuf:"bytes,2,opt,name=gitCommit,proto3" json:"gitCommit,omitempty"`
	BuildTime int64  `protobuf:"varint,3,opt,name=buildTime,proto3" json:"buildTime,omitempty"`
	Goos      string `protobuf:"bytes,4,opt,name=goos,proto3" json:"goos,omitempty"`
	Arch      string `protobuf:"bytes,5,opt,name=arch,proto3" json:"arch,omitempty"`
	Gov       string `protobuf:"bytes,6,opt,name=gov,proto3" json:"gov,omitempty"`
}

func (m *GpmInfo) Reset()         { *m = GpmInfo{} }
func (m *GpmInfo) String() string { return proto.CompactTextString(m) }
func (*GpmInfo) ProtoMessage()    {}
func (*GpmInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{4}
}
func (m *GpmInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GpmInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GpmInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GpmInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GpmInfo.Merge(m, src)
}
func (m *GpmInfo) XXX_Size() int {
	return m.XSize()
}
func (m *GpmInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GpmInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GpmInfo proto.InternalMessageInfo

type ServiceVersion struct {
	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Timestamp string `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ServiceVersion) Reset()         { *m = ServiceVersion{} }
func (m *ServiceVersion) String() string { return proto.CompactTextString(m) }
func (*ServiceVersion) ProtoMessage()    {}
func (*ServiceVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{5}
}
func (m *ServiceVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceVersion.Merge(m, src)
}
func (m *ServiceVersion) XXX_Size() int {
	return m.XSize()
}
func (m *ServiceVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceVersion.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceVersion proto.InternalMessageInfo

type FileInfo struct {
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Size    int64  `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Mode    string `protobuf:"bytes,3,opt,name=mode,proto3" json:"mode,omitempty"`
	ModTime int64  `protobuf:"varint,4,opt,name=modTime,proto3" json:"modTime,omitempty"`
	IsDir   bool   `protobuf:"varint,5,opt,name=IsDir,proto3" json:"IsDir,omitempty"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_660b025bf3ac492a, []int{6}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.XSize()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Service)(nil), "gpmv1.Service")
	proto.RegisterMapType((map[string]string)(nil), "gpmv1.Service.EnvEntry")
	proto.RegisterType((*SysProcAttr)(nil), "gpmv1.SysProcAttr")
	proto.RegisterType((*ProcLog)(nil), "gpmv1.ProcLog")
	proto.RegisterType((*Stat)(nil), "gpmv1.Stat")
	proto.RegisterType((*GpmInfo)(nil), "gpmv1.GpmInfo")
	proto.RegisterType((*ServiceVersion)(nil), "gpmv1.ServiceVersion")
	proto.RegisterType((*FileInfo)(nil), "gpmv1.FileInfo")
}

func init() {
	proto.RegisterFile("github.com/gpm2/gpm/proto/apis/gpm/v1/gpm.proto", fileDescriptor_660b025bf3ac492a)
}

var fileDescriptor_660b025bf3ac492a = []byte{
	// 665 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x6e, 0xd3, 0x4a,
	0x14, 0x8e, 0xeb, 0xa4, 0x49, 0x4e, 0xa4, 0xde, 0x7b, 0x47, 0xf7, 0xb6, 0x73, 0xab, 0xca, 0x58,
	0x59, 0xa0, 0x20, 0x50, 0xa2, 0x16, 0x84, 0x10, 0xac, 0x28, 0x14, 0x54, 0x89, 0x45, 0x35, 0x20,
	0x16, 0x2c, 0x90, 0x1c, 0x7b, 0x70, 0x47, 0x64, 0x3c, 0xd6, 0xcc, 0xd8, 0x52, 0x78, 0x0a, 0xb6,
	0x3c, 0x02, 0x6f, 0xd2, 0x65, 0x97, 0x2c, 0xa1, 0x7d, 0x11, 0x74, 0xc6, 0xe3, 0x26, 0x94, 0x2e,
	0xd8, 0x24, 0xdf, 0xf9, 0xce, 0x77, 0x32, 0xe7, 0x37, 0x30, 0xcb, 0x85, 0x3d, 0xad, 0xe6, 0xd3,
	0x54, 0xc9, 0x59, 0x5e, 0xca, 0x03, 0xfc, 0x98, 0x95, 0x5a, 0x59, 0x35, 0x4b, 0x4a, 0x61, 0x9c,
	0x59, 0xef, 0xe3, 0xd7, 0xd4, 0xb1, 0xa4, 0x97, 0x97, 0xb2, 0xde, 0x1f, 0x7f, 0xed, 0x42, 0xff,
	0x35, 0xd7, 0xb5, 0x48, 0x39, 0x21, 0xd0, 0x2d, 0x12, 0xc9, 0x69, 0x10, 0x07, 0x93, 0x21, 0x73,
	0x98, 0xfc, 0x0d, 0xe1, 0x5c, 0x14, 0x74, 0xc3, 0x51, 0x08, 0x51, 0x95, 0xe8, 0xdc, 0xd0, 0x30,
	0x0e, 0x51, 0x85, 0x18, 0x55, 0xa5, 0xc8, 0x68, 0x37, 0x0e, 0x26, 0x21, 0x43, 0x88, 0x4c, 0x26,
	0x34, 0xed, 0x35, 0x71, 0x99, 0xd0, 0xe4, 0x0e, 0x84, 0xbc, 0xa8, 0xe9, 0x66, 0x1c, 0x4e, 0x46,
	0x07, 0x3b, 0x53, 0xf7, 0xfc, 0xd4, 0x3f, 0x3d, 0x3d, 0x2a, 0xea, 0xa3, 0xc2, 0xea, 0x25, 0x43,
	0x0d, 0x79, 0x00, 0x23, 0xb3, 0x34, 0x27, 0x5a, 0xa5, 0x4f, 0xad, 0xd5, 0xb4, 0x1f, 0x07, 0x93,
	0xd1, 0x01, 0x69, 0x43, 0x56, 0x1e, 0xb6, 0x2e, 0x23, 0x31, 0x84, 0x0b, 0x95, 0xd3, 0x81, 0x53,
	0x6f, 0x79, 0x35, 0x7a, 0x5f, 0xa9, 0x9c, 0xa1, 0x8b, 0x50, 0xe8, 0xd7, 0x5c, 0x1b, 0xa1, 0x0a,
	0x3a, 0x74, 0x89, 0xb5, 0x26, 0x89, 0x61, 0x94, 0x54, 0x56, 0x31, 0x6e, 0x6c, 0xa2, 0x2d, 0x85,
	0x38, 0x98, 0xf4, 0xd8, 0x3a, 0x45, 0xee, 0xc1, 0x3f, 0xa9, 0xe6, 0x89, 0x15, 0xaa, 0x78, 0x23,
	0x24, 0x92, 0xb2, 0xa4, 0xff, 0xb9, 0x82, 0x7f, 0x77, 0x90, 0x09, 0xfc, 0x55, 0x95, 0x59, 0x62,
	0xf9, 0x4a, 0xbb, 0xed, 0xb4, 0xd7, 0x69, 0x72, 0x1b, 0xb6, 0xdc, 0x03, 0x2b, 0xe1, 0x8e, 0x13,
	0x5e, 0x63, 0xc9, 0x36, 0x6c, 0x1a, 0x9b, 0xd8, 0xca, 0x50, 0xea, 0x52, 0xf7, 0x16, 0x36, 0x5a,
	0x9a, 0x9c, 0xfe, 0xdf, 0x34, 0x5a, 0x9a, 0x9c, 0xdc, 0x82, 0x2e, 0xfa, 0xe8, 0xae, 0x6b, 0xc4,
	0xa8, 0x6d, 0x9b, 0x4d, 0x2c, 0x73, 0x8e, 0xdd, 0x87, 0x30, 0x68, 0xfb, 0x8d, 0xe1, 0x1f, 0xf9,
	0xd2, 0x8f, 0x1c, 0x21, 0xf9, 0x17, 0x7a, 0x75, 0xb2, 0xa8, 0xb8, 0x9f, 0x79, 0x63, 0x3c, 0xde,
	0x78, 0x14, 0x8c, 0x0d, 0x8c, 0xd6, 0x9a, 0x8f, 0x19, 0xa5, 0xa7, 0x5a, 0x29, 0xeb, 0xa3, 0xbd,
	0x85, 0x3f, 0x59, 0x89, 0xcc, 0x85, 0xf7, 0x18, 0x42, 0x5c, 0x99, 0xca, 0x70, 0x4d, 0xc3, 0x66,
	0xb1, 0x10, 0xa3, 0x2a, 0xf7, 0x2b, 0xd3, 0x63, 0x08, 0xf1, 0xe1, 0x5c, 0xab, 0xaa, 0xf4, 0x4b,
	0xd3, 0x18, 0xe3, 0x21, 0xf4, 0xfd, 0x0c, 0xc7, 0xef, 0xa1, 0x8b, 0x55, 0x90, 0x08, 0x20, 0x2d,
	0xab, 0x13, 0xae, 0x53, 0x5e, 0x34, 0x8f, 0x07, 0x6c, 0x8d, 0xc1, 0xc4, 0x24, 0x97, 0x4a, 0x2f,
	0x5d, 0x0e, 0x5d, 0xe6, 0x2d, 0x8c, 0x93, 0x5c, 0xb6, 0x71, 0x98, 0xcc, 0x06, 0x5b, 0x63, 0xc6,
	0x5f, 0x02, 0xe8, 0xbf, 0x2c, 0xe5, 0x71, 0xf1, 0x41, 0xad, 0xaf, 0x4a, 0xf0, 0xeb, 0xaa, 0xec,
	0xc1, 0x30, 0x17, 0xf6, 0x99, 0x92, 0x52, 0x58, 0xdf, 0xa3, 0x15, 0x81, 0xde, 0x79, 0x25, 0x16,
	0x19, 0x0e, 0xce, 0x3d, 0x11, 0xb2, 0x15, 0x81, 0x8d, 0xc8, 0x95, 0x32, 0xae, 0xea, 0x21, 0x73,
	0xb8, 0xb9, 0xa7, 0xf4, 0xd4, 0x57, 0xed, 0xb0, 0x6b, 0x8e, 0xc2, 0x5b, 0x71, 0x53, 0xc9, 0x55,
	0x3d, 0x3e, 0x84, 0x2d, 0x7f, 0x2b, 0x6f, 0x7d, 0x1e, 0x37, 0x5d, 0xeb, 0x1e, 0x0c, 0xed, 0xd5,
	0x1e, 0xf9, 0xdc, 0xae, 0x88, 0x71, 0x0d, 0x83, 0x17, 0x62, 0xc1, 0x5d, 0x7d, 0x37, 0x45, 0x13,
	0xe8, 0x1a, 0xf1, 0xa9, 0x19, 0x7c, 0xc8, 0x1c, 0x46, 0x4e, 0xaa, 0x8c, 0xb7, 0xa3, 0x43, 0x8c,
	0xbd, 0x91, 0xaa, 0xa9, 0xb0, 0xb9, 0xf8, 0xd6, 0xc4, 0x11, 0x1e, 0x9b, 0xe7, 0xfe, 0xee, 0x07,
	0xac, 0x31, 0x0e, 0x8f, 0xcf, 0x7e, 0x44, 0x9d, 0xb3, 0x8b, 0x28, 0x38, 0xbf, 0x88, 0x82, 0xef,
	0x17, 0x51, 0xf0, 0xf9, 0x32, 0xea, 0x9c, 0x5f, 0x46, 0x9d, 0x6f, 0x97, 0x51, 0xe7, 0xdd, 0xdd,
	0x3f, 0xfa, 0xe7, 0x7a, 0xe2, 0xb6, 0x78, 0xbe, 0xe9, 0x1c, 0xf7, 0x7f, 0x06, 0x00, 0x00, 0xff,
	0xff, 0x5b, 0x51, 0xaf, 0xd7, 0xef, 0x04, 0x00, 0x00,
}

func (m *Service) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	l = len(m.Bin)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovGpm(uint64(l))
		}
	}
	if m.Pid != 0 {
		n += 1 + sovGpm(uint64(m.Pid))
	}
	l = len(m.Dir)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovGpm(uint64(len(k))) + 1 + len(v) + sovGpm(uint64(len(v)))
			n += mapEntrySize + 1 + sovGpm(uint64(mapEntrySize))
		}
	}
	if m.SysProcAttr != nil {
		l = m.SysProcAttr.XSize()
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.Log != nil {
		l = m.Log.XSize()
		n += 1 + l + sovGpm(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.AutoRestart != 0 {
		n += 1 + sovGpm(uint64(m.AutoRestart))
	}
	if m.CreationTimestamp != 0 {
		n += 2 + sovGpm(uint64(m.CreationTimestamp))
	}
	if m.UpdateTimestamp != 0 {
		n += 2 + sovGpm(uint64(m.UpdateTimestamp))
	}
	if m.StartTimestamp != 0 {
		n += 2 + sovGpm(uint64(m.StartTimestamp))
	}
	l = len(m.Status)
	if l > 0 {
		n += 2 + l + sovGpm(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 2 + l + sovGpm(uint64(l))
	}
	if m.Stat != nil {
		l = m.Stat.XSize()
		n += 2 + l + sovGpm(uint64(l))
	}
	return n
}

func (m *SysProcAttr) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chroot)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovGpm(uint64(m.Uid))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.Gid != 0 {
		n += 1 + sovGpm(uint64(m.Gid))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	return n
}

func (m *ProcLog) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Stat) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuPercent != 0 {
		n += 9
	}
	if m.Memory != 0 {
		n += 1 + sovGpm(uint64(m.Memory))
	}
	if m.MemPercent != 0 {
		n += 5
	}
	return n
}

func (m *GpmInfo) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	l = len(m.GitCommit)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.BuildTime != 0 {
		n += 1 + sovGpm(uint64(m.BuildTime))
	}
	l = len(m.Goos)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	l = len(m.Arch)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	l = len(m.Gov)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	return n
}

func (m *ServiceVersion) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	l = len(m.Timestamp)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	return n
}

func (m *FileInfo) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.Size != 0 {
		n += 1 + sovGpm(uint64(m.Size))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovGpm(uint64(l))
	}
	if m.ModTime != 0 {
		n += 1 + sovGpm(uint64(m.ModTime))
	}
	if m.IsDir {
		n += 2
	}
	return n
}

func sovGpm(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func sozGpm(x uint64) (n int) {
	return sovGpm(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stat != nil {
		{
			size, err := m.Stat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGpm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.StartTimestamp != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.StartTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.UpdateTimestamp != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.UpdateTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.CreationTimestamp != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.CreationTimestamp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AutoRestart != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.AutoRestart))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Log != nil {
		{
			size, err := m.Log.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGpm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SysProcAttr != nil {
		{
			size, err := m.SysProcAttr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGpm(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Env) > 0 {
		for k := range m.Env {
			v := m.Env[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintGpm(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintGpm(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintGpm(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Dir) > 0 {
		i -= len(m.Dir)
		copy(dAtA[i:], m.Dir)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Dir)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Pid != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.Pid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintGpm(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Bin) > 0 {
		i -= len(m.Bin)
		copy(dAtA[i:], m.Bin)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Bin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SysProcAttr) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysProcAttr) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysProcAttr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Gid != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Chroot) > 0 {
		i -= len(m.Chroot)
		copy(dAtA[i:], m.Chroot)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Chroot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProcLog) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Stat) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Stat) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Stat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemPercent != 0 {
		i -= 4
		ebinary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemPercent))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Memory != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuPercent != 0 {
		i -= 8
		ebinary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.CpuPercent))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *GpmInfo) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GpmInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GpmInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gov) > 0 {
		i -= len(m.Gov)
		copy(dAtA[i:], m.Gov)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Gov)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Arch) > 0 {
		i -= len(m.Arch)
		copy(dAtA[i:], m.Arch)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Arch)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Goos) > 0 {
		i -= len(m.Goos)
		copy(dAtA[i:], m.Goos)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Goos)))
		i--
		dAtA[i] = 0x22
	}
	if m.BuildTime != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.BuildTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GitCommit) > 0 {
		i -= len(m.GitCommit)
		copy(dAtA[i:], m.GitCommit)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.GitCommit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceVersion) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Timestamp) > 0 {
		i -= len(m.Timestamp)
		copy(dAtA[i:], m.Timestamp)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Timestamp)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsDir {
		i--
		if m.IsDir {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ModTime != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.ModTime))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Mode) > 0 {
		i -= len(m.Mode)
		copy(dAtA[i:], m.Mode)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Mode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Size != 0 {
		i = encodeVarintGpm(dAtA, i, uint64(m.Size))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGpm(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGpm(dAtA []byte, offset int, v uint64) int {
	offset -= sovGpm(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGpm
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGpm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthGpm
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthGpm
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGpm
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthGpm
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthGpm
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipGpm(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthGpm
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysProcAttr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SysProcAttr == nil {
				m.SysProcAttr = &SysProcAttr{}
			}
			if err := m.SysProcAttr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Log == nil {
				m.Log = &ProcLog{}
			}
			if err := m.Log.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRestart", wireType)
			}
			m.AutoRestart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoRestart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			m.CreationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTimestamp", wireType)
			}
			m.UpdateTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTimestamp", wireType)
			}
			m.StartTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stat == nil {
				m.Stat = &Stat{}
			}
			if err := m.Stat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysProcAttr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysProcAttr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysProcAttr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chroot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chroot = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Stat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Stat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Stat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(ebinary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.CpuPercent = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemPercent", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(ebinary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemPercent = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GpmInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GpmInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GpmInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitCommit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTime", wireType)
			}
			m.BuildTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuildTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gov", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gov = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timestamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size", wireType)
			}
			m.Size = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGpm
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGpm
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTime", wireType)
			}
			m.ModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDir", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDir = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGpm(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGpm
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGpm(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGpm
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGpm
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGpm
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGpm
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGpm
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGpm        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGpm          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGpm = fmt.Errorf("proto: unexpected end of group")
)
